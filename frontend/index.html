<!DOCTYPE html>
<html lang="en">
    
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cognitive Geospatial Assistant</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            display: flex;
            flex-direction: column;
            height: 100vh;
            background: linear-gradient(135deg, #0f0d1a 0%, #1a1825 50%, #251f35 100%);
            backdrop-filter: blur(10px);
            color: #f5f5f5;
        }

        /* Top Search Bar */
        .search-header {
            background: rgba(26, 24, 37, 0.7);
            backdrop-filter: blur(25px) saturate(180%);
            border-bottom: 1.5px solid rgba(196, 195, 227, 0.2);
            padding: 1rem 1.5rem;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            z-index: 1000;
        }

        .search-container {
            max-width: 1400px;
            margin: 0 auto;
            display: flex;
            align-items: center;
            gap: 1.2rem;
            justify-content: space-between;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            background: linear-gradient(135deg, #504E76 0%, #F1642E 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            white-space: nowrap;
        }

        .search-wrapper {
            flex: 1;
            min-width: 300px;
            max-width: 600px;
            position: relative;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        #searchInput {
            flex: 1;
            padding: 0.75rem 2.5rem 0.75rem 2.5rem;
            background: rgba(37, 32, 53, 0.6);
            border: 1.5px solid rgba(196, 195, 227, 0.25);
            border-radius: 50px;
            font-size: 0.95rem;
            font-family: inherit;
            backdrop-filter: blur(15px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: #f5f5f5;
            height: 40px;
        }

        #searchInput::placeholder {
            color: rgba(196, 195, 227, 0.5);
        }

        #searchInput:focus {
            outline: none;
            background: rgba(37, 32, 53, 0.9);
            border-color: rgba(241, 100, 46, 0.6);
            box-shadow: 0 8px 24px rgba(241, 100, 46, 0.2);
        }

        .search-icon {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            color: rgba(196, 195, 227, 0.6);
            font-size: 1.2rem;
            pointer-events: none;
        }

        #searchBtn {
            padding: 0.6rem 1.5rem;
            background: rgba(241, 100, 46, 0.85);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.4);
            border-radius: 50px;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(15px);
            box-shadow:
                0 8px 16px rgba(241, 100, 46, 0.25),
                inset 0 1px 2px rgba(255, 255, 255, 0.4);
            position: relative;
            overflow: hidden;
            white-space: nowrap;
            height: 40px;
            display: flex;
            align-items: center;
        }

        #searchBtn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: 0;
            right: 0;
            height: 200%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.3), transparent);
            pointer-events: none;
        }

        #searchBtn:hover:not(:disabled) {
            transform: translateY(-2px);
            background: rgba(80, 78, 118, 0.95);
            box-shadow: 0 12px 24px rgba(80, 78, 118, 0.3);
        }

        #searchBtn:active:not(:disabled) {
            transform: translateY(0);
        }

        #searchBtn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Main Content Area */
        .main-container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Left Layers Panel */
        .layers-panel {
            width: 320px;
            background: rgba(26, 24, 37, 0.5);
            backdrop-filter: blur(25px) saturate(180%);
            border-right: 1.5px solid rgba(196, 195, 227, 0.2);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .panel-header {
            padding: 1rem 1.5rem;
            background: rgba(37, 32, 53, 0.4);
            backdrop-filter: blur(15px);
            border-bottom: 1.5px solid rgba(196, 195, 227, 0.15);
            font-weight: 600;
            color: #f5f5f5;
            font-size: 0.95rem;
            letter-spacing: 0.5px;
        }

        .layers-list {
            flex: 1;
            overflow-y: auto;
            padding: 0.5rem;
        }

        .layer-item {
            background: rgba(37, 32, 53, 0.45);
            border: 1.5px solid rgba(196, 195, 227, 0.2);
            border-radius: 12px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            backdrop-filter: blur(15px);
            color: #f5f5f5;
        }

        .layer-item:hover {
            background: rgba(37, 32, 53, 0.7);
            border-color: rgba(241, 100, 46, 0.4);
            box-shadow: 0 8px 24px rgba(241, 100, 46, 0.15);
            transform: translateY(-2px);
        }

        .layer-item.active {
            background: rgba(241, 100, 46, 0.15);
            border-color: rgba(241, 100, 46, 0.4);
            box-shadow: 0 8px 24px rgba(241, 100, 46, 0.2);
        }

        .layer-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .layer-name {
            font-weight: 600;
            color: #f5f5f5;
            font-size: 0.9rem;
            flex: 1;
            min-width: 0;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .layer-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .layer-color-picker {
            width: 28px;
            height: 28px;
            border: 1.5px solid rgba(255, 255, 255, 0.4);
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.5);
            backdrop-filter: blur(10px);
            box-shadow: inset 0 0 8px rgba(255, 255, 255, 0.5);
        }

        .layer-color-picker:hover {
            border-color: rgba(80, 78, 118, 0.5);
            transform: scale(1.08);
            box-shadow: 0 8px 16px rgba(80, 78, 118, 0.2), inset 0 0 8px rgba(255, 255, 255, 0.5);
        }

        .layer-color-picker input[type="color"] {
            position: absolute;
            top: -5px;
            left: -5px;
            width: 150%;
            height: 150%;
            border: none;
            cursor: pointer;
            background: transparent;
        }

        .layer-color-display {
            position: absolute;
            top: 2px;
            left: 2px;
            width: calc(100% - 4px);
            height: calc(100% - 4px);
            border-radius: 3px;
            pointer-events: none;
        }

        .layer-toggle {
            width: 40px;
            height: 20px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 10px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            backdrop-filter: blur(10px);
        }

        .layer-toggle.active {
            background: rgba(80, 78, 118, 0.6);
            border-color: rgba(80, 78, 118, 0.4);
            box-shadow: 0 4px 12px rgba(80, 78, 118, 0.15);
        }

        .layer-toggle::after {
            content: '';
            position: absolute;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            top: 3px;
            left: 3px;
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.15);
        }

        .layer-toggle.active::after {
            transform: translateX(20px);
        }

        .layer-remove {
            color: #dc3545;
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0 0.25rem;
            opacity: 0.6;
            transition: opacity 0.2s;
        }

        .layer-remove:hover {
            opacity: 1;
        }

        .layer-info {
            display: flex;
            justify-content: space-between;
            margin-top: 0.5rem;
            padding-top: 0.5rem;
            border-top: 1px solid #f0f0f0;
            font-size: 0.8rem;
            color: #666;
        }

        .layer-count {
            display: flex;
            align-items: center;
            gap: 0.25rem;
        }

        .layer-time {
            font-size: 0.75rem;
            color: #999;
        }

        .empty-state {
            text-align: center;
            padding: 3rem 1.5rem;
            color: #999999;
        }

        .empty-state-icon {
            font-size: 3rem;
            margin-bottom: 1rem;
            opacity: 0.4;
        }

        .empty-state-text {
            font-size: 0.9rem;
            color: #b0b0b0;
        }

        /* Map */
        #map {
            flex: 1;
            height: 100%;
            position: relative;
        }

        /* Locate Me Button */
        .locate-btn {
            position: absolute;
            bottom: 30px;
            right: 20px;
            z-index: 1000;
            width: 44px;
            height: 44px;
            background: rgba(37, 32, 53, 0.75);
            border: 1.5px solid rgba(241, 100, 46, 0.4);
            border-radius: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow:
                0 8px 24px rgba(0, 0, 0, 0.3),
                inset 0 1px 2px rgba(241, 100, 46, 0.2);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(10px);
            color: #F1642E;
            position: relative;
            overflow: hidden;
        }

        .locate-btn::before {
            content: '';
            position: absolute;
            top: -50%;
            left: 0;
            right: 0;
            height: 200%;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.4), transparent);
            pointer-events: none;
        }

        .locate-btn:hover {
            background: rgba(80, 78, 118, 0.7);
            color: white;
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-4px);
            box-shadow: 0 12px 32px rgba(80, 78, 118, 0.25);
        }

        .locate-btn:active {
            transform: translateY(-2px);
        }

        .locate-btn.locating {
            animation: pulse 1.5s cubic-bezier(0.4, 0, 0.6, 1) infinite;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                box-shadow:
                    0 8px 24px rgba(0, 0, 0, 0.12),
                    inset 0 1px 2px rgba(255, 255, 255, 0.4),
                    0 0 0 0 rgba(80, 78, 118, 0.3);
            }
            50% {
                transform: scale(1.02);
                box-shadow:
                    0 8px 24px rgba(0, 0, 0, 0.12),
                    inset 0 1px 2px rgba(255, 255, 255, 0.4),
                    0 0 0 8px rgba(80, 78, 118, 0);
            }
        }

        /* Loading Indicator */
        .loading-indicator {
            position: absolute;
            right: 5.5rem;
            top: 50%;
            transform: translateY(-50%);
            display: none;
            z-index: 999;
        }

        .loading-indicator.active {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .loading-spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(80, 78, 118, 0.2);
            border-top-color: #504E76;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            box-shadow: inset 0 0 4px rgba(80, 78, 118, 0.1);
        }

        .loading-text-small {
            font-size: 0.8rem;
            color: #504E76;
            font-weight: 500;
            white-space: nowrap;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Modern popup card styles */
        .leaflet-popup-content-wrapper {
            border-radius: 16px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.2);
            padding: 0;
            max-width: 400px !important;
            max-height: 500px;
            overflow: hidden;
            background: rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.4);
            backdrop-filter: blur(10px);
        }

        .leaflet-popup-content {
            margin: 0;
            max-height: 480px;
            overflow-y: auto;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
        }

        .popup-card {
            display: flex;
            flex-direction: column;
        }

        .popup-header {
            background: linear-gradient(135deg, rgba(80, 78, 118, 0.9) 0%, rgba(241, 100, 46, 0.9) 100%);
            color: white;
            padding: 1rem;
            font-weight: 600;
            font-size: 1rem;
            border-top-left-radius: 16px;
            border-top-right-radius: 16px;
            backdrop-filter: blur(10px);
        }

        .popup-body {
            padding: 1rem;
            background: rgba(255, 255, 255, 0.5);
        }

        .popup-attribute {
            display: grid;
            grid-template-columns: 140px 1fr;
            gap: 0.75rem;
            padding: 0.75rem;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.2s;
        }

        .popup-attribute:hover {
            background: #f8f9fa;
        }

        .popup-attribute:last-child {
            border-bottom: none;
        }

        .popup-label {
            font-weight: 600;
            color: #555;
            font-size: 0.85rem;
            text-transform: capitalize;
            word-break: break-word;
        }

        .popup-value {
            color: #333;
            font-size: 0.85rem;
            word-break: break-word;
            line-height: 1.4;
        }

        .popup-footer {
            padding: 0.75rem 1rem;
            background: rgba(255, 255, 255, 0.4);
            border-top: 1px solid rgba(255, 255, 255, 0.3);
            font-size: 0.75rem;
            color: #666;
            text-align: center;
            backdrop-filter: blur(10px);
        }

        .leaflet-popup-tip-container {
            display: none;
        }

        .leaflet-popup-close-button {
            color: white !important;
            font-size: 24px !important;
            padding: 4px 8px !important;
            width: auto !important;
            height: auto !important;
            top: 8px !important;
            right: 8px !important;
        }

        .leaflet-popup-close-button:hover {
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
        }

        /* Notification */
        .notification {
            position: fixed;
            top: 100px;
            right: 2rem;
            background: rgba(37, 32, 53, 0.85);
            backdrop-filter: blur(25px) saturate(180%);
            padding: 1rem 1.5rem;
            border-radius: 12px;
            border: 1.5px solid rgba(241, 100, 46, 0.3);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
            color: #f5f5f5;
            z-index: 1500;
            display: none;
            animation: slideIn 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .notification.error {
            border-left: 3px solid #dc3545;
        }

        .notification.success {
            border-left: 3px solid #28a745;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes float {
            0%, 100% {
                transform: translateY(0px);
            }
            50% {
                transform: translateY(-4px);
            }
        }

        @keyframes glassShimmer {
            0% {
                background-position: -1000px 0;
            }
            100% {
                background-position: 1000px 0;
            }
        }

        /* Location Button */
        .location-btn {
            padding: 0.6rem 1.2rem;
            background: rgba(37, 32, 53, 0.6);
            border: 1.5px solid rgba(196, 195, 227, 0.25);
            border-radius: 50px;
            font-size: 0.9rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            white-space: nowrap;
            backdrop-filter: blur(15px);
            color: #f5f5f5;
            height: 40px;
            box-shadow:
                0 8px 16px rgba(0, 0, 0, 0.2),
                inset 0 1px 2px rgba(196, 195, 227, 0.1);
        }

        .location-btn:hover:not(:disabled) {
            background: rgba(37, 32, 53, 0.85);
            border-color: rgba(241, 100, 46, 0.4);
            box-shadow: 0 12px 24px rgba(241, 100, 46, 0.15);
            transform: translateY(-2px);
        }

        .location-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .location-btn.active {
            background: rgba(241, 100, 46, 0.7);
            color: white;
            border-color: rgba(241, 100, 46, 0.4);
            box-shadow: 0 8px 24px rgba(241, 100, 46, 0.25);
        }

        .location-status {
            font-size: 0.75rem;
            color: #666;
            margin-left: 0.5rem;
        }

        /* Right Operations Panel */
        .operations-panel {
            width: 350px;
            background: rgba(26, 24, 37, 0.6);
            backdrop-filter: blur(25px) saturate(180%);
            border-left: 2px solid rgba(196, 195, 227, 0.35);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .operations-panel-hidden {
            display: none;
        }

        .operations-header {
            padding: 1rem 1.5rem;
            background: rgba(80, 78, 118, 0.3);
            backdrop-filter: blur(15px);
            border-bottom: 2px solid rgba(196, 195, 227, 0.25);
            font-weight: 600;
            color: #C4C3E3;
            font-size: 0.95rem;
            letter-spacing: 0.5px;
        }

        .operations-content {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
        }

        .no-selection {
            text-align: center;
            padding: 2rem 1rem;
            color: #b0b0b0;
            font-size: 0.9rem;
        }

        .operations-section {
            margin-bottom: 1.5rem;
        }

        .operations-section-title {
            font-weight: 600;
            color: #F1642E;
            font-size: 0.9rem;
            margin-bottom: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .reasoning-box {
            background: rgba(196, 195, 227, 0.12);
            border-left: 3px solid rgba(196, 195, 227, 0.6);
            padding: 0.75rem;
            border-radius: 8px;
            font-size: 0.85rem;
            color: #f5f5f5;
            line-height: 1.5;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(196, 195, 227, 0.2);
        }

        .operation-item {
            background: rgba(80, 78, 118, 0.15);
            border: 1.5px solid rgba(196, 195, 227, 0.25);
            border-radius: 8px;
            padding: 0.75rem;
            margin-bottom: 0.5rem;
            backdrop-filter: blur(15px);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: #f5f5f5;
        }

        .operation-item:hover {
            background: rgba(80, 78, 118, 0.25);
            box-shadow: 0 8px 24px rgba(196, 195, 227, 0.15);
            border-color: rgba(196, 195, 227, 0.45);
        }

        .operation-type {
            display: inline-block;
            background: rgba(80, 78, 118, 0.6);
            color: #C4C3E3;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            border: 1px solid rgba(196, 195, 227, 0.3);
            box-shadow: 0 4px 12px rgba(196, 195, 227, 0.12);
        }

        .operation-description {
            font-size: 0.85rem;
            color: #f5f5f5;
            margin-bottom: 0.5rem;
            font-weight: 500;
        }

        .operation-params {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(196, 195, 227, 0.15);
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.75rem;
            color: #a0a0a0;
            font-family: 'Monaco', 'Menlo', 'Courier New', monospace;
            overflow-x: auto;
            max-height: 80px;
            overflow-y: auto;
            backdrop-filter: blur(5px);
        }

        .datasets-list {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .dataset-badge {
            background: rgba(163, 181, 101, 0.5);
            color: #FDF8E2;
            padding: 0.35rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 600;
            border: 1px solid rgba(196, 195, 227, 0.25);
            box-shadow: 0 4px 12px rgba(163, 181, 101, 0.12);
        }

        .metadata-item {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid rgba(196, 195, 227, 0.2);
            font-size: 0.85rem;
        }

        .metadata-item:last-child {
            border-bottom: none;
        }

        .metadata-label {
            color: #C4C3E3;
            font-weight: 500;
        }

        .metadata-value {
            color: #FDF8E2;
            font-weight: 600;
        }

        /* Leaflet Dark Mode Styling */
        .leaflet-control {
            background: rgba(37, 32, 53, 0.8) !important;
            border: 1.5px solid rgba(196, 195, 227, 0.2) !important;
            backdrop-filter: blur(10px) !important;
        }

        .leaflet-control-zoom-in,
        .leaflet-control-zoom-out {
            color: #F1642E !important;
            background: rgba(37, 32, 53, 0.8) !important;
            border: 1px solid rgba(241, 100, 46, 0.3) !important;
        }

        .leaflet-control-zoom-in:hover,
        .leaflet-control-zoom-out:hover {
            background: rgba(37, 32, 53, 0.95) !important;
            border-color: rgba(241, 100, 46, 0.5) !important;
        }

        .leaflet-control-attribution {
            background: rgba(37, 32, 53, 0.7) !important;
            color: #b0b0b0 !important;
            border: 1px solid rgba(196, 195, 227, 0.15) !important;
            backdrop-filter: blur(10px) !important;
        }

        .leaflet-control-attribution a {
            color: #F1642E !important;
        }

        .leaflet-control-attribution a:hover {
            color: #FCDD9D !important;
        }

        .leaflet-popup {
            filter: drop-shadow(0 8px 32px rgba(0, 0, 0, 0.5));
        }

        /* Hide map container and adjust for panels */
        .map-wrapper {
            flex: 1;
            display: flex;
            overflow: hidden;
        }


        /* Layer Menu (3-dots) */
        .layer-menu-btn {
            width: 28px;
            height: 28px;
            border: none;
            background: rgba(80, 78, 118, 0.4);
            border-radius: 6px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #f5f5f5;
            font-size: 1.2rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            padding: 0;
            line-height: 1;
        }

        .layer-menu-btn:hover {
            background: rgba(80, 78, 118, 0.7);
            transform: scale(1.08);
        }

        .layer-dropdown-menu {
            position: absolute;
            top: 100%;
            right: 0;
            background: rgba(26, 24, 37, 0.95);
            backdrop-filter: blur(25px);
            border: 1.5px solid rgba(196, 195, 227, 0.3);
            border-radius: 10px;
            margin-top: 0.5rem;
            z-index: 1001;
            min-width: 180px;
            box-shadow: 0 12px 32px rgba(0, 0, 0, 0.5);
            display: none;
        }

        .layer-dropdown-menu.active {
            display: block;
        }

        .layer-dropdown-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            color: #f5f5f5;
            font-size: 0.9rem;
            transition: all 0.2s ease;
            border-bottom: 1px solid rgba(196, 195, 227, 0.1);
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .layer-dropdown-item:last-child {
            border-bottom: none;
        }

        .layer-dropdown-item:hover {
            background: rgba(80, 78, 118, 0.3);
            padding-left: 1.25rem;
        }

        .layer-dropdown-item.delete:hover {
            background: rgba(241, 100, 46, 0.2);
            color: #F1642E;
        }

        /* Export Dialog */
        .export-dialog-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px);
            z-index: 2000;
            justify-content: center;
            align-items: center;
        }

        .export-dialog-overlay.active {
            display: flex;
        }

        .export-dialog {
            background: linear-gradient(135deg, rgba(26, 24, 37, 0.98) 0%, rgba(37, 32, 53, 0.95) 100%);
            backdrop-filter: blur(25px);
            border: 1.5px solid rgba(196, 195, 227, 0.3);
            border-radius: 16px;
            padding: 2rem;
            max-width: 500px;
            width: 90%;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.6);
            color: #f5f5f5;
            animation: slideUp 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .export-dialog-header {
            font-size: 1.5rem;
            font-weight: 700;
            margin-bottom: 1.5rem;
            color: #C4C3E3;
        }

        .export-dialog-content {
            margin-bottom: 2rem;
        }

        .export-option {
            margin-bottom: 1.5rem;
        }

        .export-option-label {
            display: block;
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: #f5f5f5;
            font-size: 0.95rem;
        }

        .export-option-description {
            font-size: 0.85rem;
            color: #b0b0b0;
            margin-bottom: 0.75rem;
        }

        .export-checkbox {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 8px;
            transition: all 0.2s ease;
        }

        .export-checkbox:hover {
            background: rgba(80, 78, 118, 0.2);
        }

        .export-checkbox input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #F1642E;
        }

        .export-format-select {
            padding: 0.75rem 1rem;
            background: rgba(37, 32, 53, 0.8);
            border: 1.5px solid rgba(196, 195, 227, 0.25);
            border-radius: 8px;
            color: #f5f5f5;
            font-family: inherit;
            font-size: 0.95rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .export-format-select:hover {
            border-color: rgba(241, 100, 46, 0.5);
        }

        .export-format-select:focus {
            outline: none;
            border-color: rgba(241, 100, 46, 0.7);
            box-shadow: 0 0 12px rgba(241, 100, 46, 0.2);
        }

        .export-dialog-actions {
            display: flex;
            gap: 1rem;
            justify-content: flex-end;
        }

        .export-btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-size: 0.95rem;
        }

        .export-btn-primary {
            background: linear-gradient(135deg, #504E76 0%, #F1642E 100%);
            color: white;
            box-shadow: 0 8px 20px rgba(241, 100, 46, 0.3);
        }

        .export-btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 28px rgba(241, 100, 46, 0.4);
        }

        .export-btn-secondary {
            background: rgba(80, 78, 118, 0.4);
            color: #f5f5f5;
            border: 1.5px solid rgba(196, 195, 227, 0.3);
        }

        .export-btn-secondary:hover {
            background: rgba(80, 78, 118, 0.6);
            border-color: rgba(196, 195, 227, 0.5);
        }

    </style>
</head>
<body>
    <!-- Top Search Bar -->
    <div class="search-header">
        <div class="search-container">
            <div class="logo">üåç GeoAssist</div>
            <div class="search-wrapper">
                <span class="search-icon">üîç</span>
                <input type="text" id="searchInput" placeholder="Ask a question... (e.g., hospitals in Mitte OR terrain elevation in Berlin)">
                <div class="loading-indicator" id="loadingIndicator">
                    <div class="loading-spinner"></div>
                    <span class="loading-text-small" id="loadingIndicatorText">Processing...</span>
                </div>
                <button id="searchBtn" onclick="executeSearch()">Search</button>
            </div>
            <button id="locationBtn" class="location-btn" onclick="toggleLocation()">
                <span id="locationIcon">üìç</span>
                <span id="locationText">My Location</span>
            </button>
        </div>
    </div>

    <!-- Main Container -->
    <div class="main-container">
        <!-- Left Layers Panel -->
        <div class="layers-panel">
            <div class="panel-header">
                Layers
            </div>
            <div class="layers-list" id="layersList">
                <div class="empty-state">
                    <div class="empty-state-icon">üó∫Ô∏è</div>
                    <div class="empty-state-text">No layers yet<br>Search to add results as layers</div>
                </div>
            </div>
        </div>

        <!-- Map Container with Operations Panel -->
        <div class="map-wrapper">
            <!-- Map -->
            <div id="map">
                <!-- Locate Me Button -->
                <button id="locateBtn" class="locate-btn" onclick="locateUser()" title="Find my location">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"></circle>
                        <circle cx="12" cy="12" r="3"></circle>
                    </svg>
                </button>
            </div>

            <!-- Right Operations Panel -->
            <div class="operations-panel operations-panel-hidden" id="operationsPanel">
                <div class="operations-header">
                    <div id="operationsTitle">Operations</div>
                </div>
                <div class="operations-content" id="operationsContent">
                    <div class="no-selection">
                        Click a layer to view operations
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Dialog -->
    <div class="export-dialog-overlay" id="exportDialogOverlay">
        <div class="export-dialog">
            <div class="export-dialog-header">üì• Export Layer as GeoJSON</div>
            
            <div class="export-dialog-content">
                <div class="export-option">
                    <label class="export-option-label">Include Properties</label>
                    <div class="export-option-description">Add feature attributes to the export</div>
                    <label class="export-checkbox">
                        <input type="checkbox" id="exportIncludeProperties" checked>
                        <span>Include feature properties</span>
                    </label>
                </div>

                <div class="export-option">
                    <label class="export-option-label">Formatting</label>
                    <div class="export-option-description">Choose output formatting</div>
                    <select class="export-format-select" id="exportFormatSelect">
                        <option value="minified">Minified (compact)</option>
                        <option value="pretty">Pretty printed (formatted)</option>
                    </select>
                </div>

                <div class="export-option">
                    <label class="export-option-label">Additional Options</label>
                    <label class="export-checkbox">
                        <input type="checkbox" id="exportIncludeCRS">
                        <span>Include CRS (Coordinate Reference System)</span>
                    </label>
                    <label class="export-checkbox">
                        <input type="checkbox" id="exportIncludeBbox">
                        <span>Include bounding box (bbox)</span>
                    </label>
                </div>
            </div>

            <div class="export-dialog-actions">
                <button class="export-btn export-btn-secondary" onclick="closeExportDialog()">Cancel</button>
                <button class="export-btn export-btn-primary" onclick="performExport()">Export</button>
            </div>
        </div>
    </div>

    <!-- Notification -->
    <div class="notification" id="notification"></div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

    <script>
        // Initialize map centered on Berlin
        const map = L.map('map').setView([52.52, 13.405], 11);

        // Define Berlin boundary (bounding box)
        // Northwest corner: [52.67, 13.08]
        // Southeast corner: [52.34, 13.76]
        const berlinBounds = L.latLngBounds(
            L.latLng(52.34, 13.08),  // Southwest
            L.latLng(52.67, 13.76)   // Northeast
        );

        // Restrict map to Berlin boundary
        map.setMaxBounds(berlinBounds);

        // Set min/max zoom levels
        map.setMinZoom(10);
        map.setMaxZoom(19);

        // Add Dark CartoDB Voyager tiles
        L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
            attribution: '¬© OpenStreetMap contributors, ¬© CARTO',
            maxZoom: 19,
            subdomains: 'abcd'
        }).addTo(map);

        // API base URL
        const API_URL = window.location.origin + '/api';

        // Store layers
        let layers = [];
        let layerIdCounter = 0;

        // User location state
        let userLocation = null;  // {lat, lon}
        let userLocationMarker = null;
        let userLocationCircle = null;
        let locationWatchId = null;

        // Show notification
        function showNotification(message, type = 'success') {
            const notification = document.getElementById('notification');
            notification.textContent = message;
            notification.className = `notification ${type}`;
            notification.style.display = 'block';

            setTimeout(() => {
                notification.style.display = 'none';
            }, 4000);
        }

        // Show/hide loading indicator
        function setLoading(isLoading, text = 'Processing...') {
            const indicator = document.getElementById('loadingIndicator');
            const loadingText = document.getElementById('loadingIndicatorText');

            if (isLoading) {
                loadingText.textContent = text;
                indicator.classList.add('active');
            } else {
                indicator.classList.remove('active');
            }
        }

        // Generate layer name from query and data
        function generateLayerName(query, geojsonData) {
            // Strategy 1: Analyze feature properties to determine what was actually returned
            if (geojsonData && geojsonData.features && geojsonData.features.length > 0) {
                const firstFeature = geojsonData.features[0].properties;

                // Check for common OSM tags
                if (firstFeature.amenity) {
                    const amenityName = firstFeature.amenity.replace(/_/g, ' ');
                    return capitalize(amenityName) + 's';
                }
                if (firstFeature.shop) {
                    const shopName = firstFeature.shop.replace(/_/g, ' ');
                    return capitalize(shopName) + 's';
                }
                if (firstFeature.tourism) {
                    return capitalize(firstFeature.tourism.replace(/_/g, ' '));
                }
                if (firstFeature.building && firstFeature.building !== 'yes') {
                    return capitalize(firstFeature.building.replace(/_/g, ' ')) + 's';
                }
                if (firstFeature.highway) {
                    return 'Roads';
                }
            }

            // Strategy 2: Smart query parsing
            const queryLower = query.toLowerCase();

            // Expanded feature keywords dictionary
            const featureKeywords = {
                // Healthcare
                'hospital': 'Hospitals',
                'clinic': 'Clinics',
                'pharmacy': 'Pharmacies',
                'pharmacies': 'Pharmacies',
                'doctor': 'Doctors',
                'dentist': 'Dentists',

                // Education
                'school': 'Schools',
                'kindergarten': 'Kindergartens',
                'university': 'Universities',
                'college': 'Colleges',
                'library': 'Libraries',
                'libraries': 'Libraries',

                // Food & Drink
                'restaurant': 'Restaurants',
                'cafe': 'Cafes',
                'bar': 'Bars',
                'pub': 'Pubs',
                'supermarket': 'Supermarkets',
                'bakery': 'Bakeries',
                'food': 'Food Places',

                // Emergency Services
                'fire station': 'Fire Stations',
                'police station': 'Police Stations',
                'police': 'Police Stations',

                // Recreation
                'park': 'Parks',
                'playground': 'Playgrounds',
                'sports': 'Sports Facilities',
                'gym': 'Gyms',
                'swimming': 'Swimming Pools',

                // Transport
                'train station': 'Train Stations',
                'bus stop': 'Bus Stops',
                'u-bahn': 'U-Bahn Stations',
                'metro': 'Metro Stations',
                'subway': 'Subway Stations',
                'station': 'Stations',
                'transport': 'Transport Stops',

                // Infrastructure
                'building': 'Buildings',
                'road': 'Roads',
                'highway': 'Highways',
                'street': 'Streets',
                'toilet': 'Toilets',
                'parking': 'Parking',
                'atm': 'ATMs',

                // Areas
                'residential area': 'Residential Areas',
                'residential': 'Residential Areas',
                'industrial area': 'Industrial Areas',
                'industrial': 'Industrial Areas',
                'commercial': 'Commercial Areas',
                'urban': 'Urban Areas',

                // Tourism
                'hotel': 'Hotels',
                'museum': 'Museums',
                'monument': 'Monuments',
                'attraction': 'Attractions',
                'tourist': 'Tourist Attractions'
            };

            // Find the main feature (check longer phrases first)
            let mainFeature = null;
            const sortedKeys = Object.keys(featureKeywords).sort((a, b) => b.length - a.length);

            for (const key of sortedKeys) {
                if (queryLower.includes(key)) {
                    mainFeature = featureKeywords[key];
                    break;
                }
            }

            // Extract location context
            const locationPatterns = [
                /(?:in|near|at|around)\s+([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)/,
                /([A-Z][a-z]+(?:\s+[A-Z][a-z]+)?)\s+(?:area|district|neighborhood)/i
            ];

            let location = null;
            for (const pattern of locationPatterns) {
                const match = query.match(pattern);
                if (match) {
                    location = match[1];
                    break;
                }
            }

            // Extract distance/proximity
            const distanceMatch = query.match(/within\s+(\d+\.?\d*)\s*(m|km|meters|kilometers)/i);
            let distance = null;
            if (distanceMatch) {
                const distValue = distanceMatch[1];
                const distUnit = distanceMatch[2].toLowerCase();
                if (distUnit.startsWith('k')) {
                    distance = distValue + 'km';
                } else {
                    distance = distValue + 'm';
                }
            }

            // Build layer name with priority: feature + location > feature + distance > feature only
            if (mainFeature && location) {
                return `${mainFeature} - ${location}`;
            } else if (mainFeature && distance) {
                return `${mainFeature} (${distance})`;
            } else if (mainFeature) {
                return mainFeature;
            }

            // Fallback: Use first 3 meaningful words from query
            const stopWords = ['find', 'show', 'search', 'where', 'what', 'which', 'that',
                              'have', 'with', 'from', 'within', 'near', 'all', 'the', 'are',
                              'more', 'than', 'less', 'between', 'and', 'or'];

            const words = query.split(/\s+/).filter(w =>
                w.length > 2 &&
                !stopWords.includes(w.toLowerCase()) &&
                !w.match(/^\d+$/)  // Exclude pure numbers
            );

            if (words.length > 0) {
                const limitedWords = words.slice(0, 3);
                return limitedWords.map(w =>
                    w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
                ).join(' ');
            }

            return 'Search Results';
        }

        // Helper function to capitalize words
        function capitalize(str) {
            return str.split(' ').map(word =>
                word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()
            ).join(' ');
        }

        // Add layer to map and panel
        function addLayer(name, geojsonData, query, operations = null, reasoning = null, datasetsUsed = null, metadata = null, executionTime = null) {
            const layerId = ++layerIdCounter;

            // Generate color for this layer
            const colors = ['#504E76', '#F1642E', '#C4C3E3', '#A3B565',
                           '#FCDD9D', '#FDF8E2', '#A3B565', '#F1642E'];
            const layerColor = colors[layerId % colors.length];

            // Create Leaflet layer
            const geojsonLayer = L.geoJSON(geojsonData, {
                style: function(feature) {
                    return {
                        color: layerColor,
                        weight: 2,
                        fillOpacity: 0.3
                    };
                },
                pointToLayer: function(feature, latlng) {
                    return L.circleMarker(latlng, {
                        radius: 8,
                        fillColor: layerColor,
                        color: '#fff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8
                    });
                },
                onEachFeature: function(feature, layer) {
                    if (feature.properties) {
                        layer.bindPopup(createPopupContent(feature.properties));
                    }
                }
            }).addTo(map);

            // Fit map to layer bounds
            if (geojsonLayer.getBounds().isValid()) {
                map.fitBounds(geojsonLayer.getBounds(), { padding: [50, 50] });
            }

            // Store layer info
            const layerInfo = {
                id: layerId,
                name: name,
                query: query,
                layer: geojsonLayer,
                visible: true,
                featureCount: geojsonData.features.length,
                timestamp: new Date(),
                color: layerColor,
                geojsonData: geojsonData,  // Store original data for re-styling
                operations: operations,     // Store operations performed
                reasoning: reasoning,       // Store AI reasoning
                datasetsUsed: datasetsUsed, // Store datasets used
                metadata: metadata,         // Store metadata
                executionTime: executionTime  // Store execution time
            };

            layers.push(layerInfo);

            // Update UI
            updateLayersPanel();
        }

        // Create popup content
        function createPopupContent(properties) {
            // Determine the feature name - check area/subdivision fields first
            let featureName = properties.name || properties.title || properties.oteil ||
                            properties.amenity || properties.highway || properties.type || 'Feature Details';

            let popupContent = '<div class="popup-card">';
            popupContent += `<div class="popup-header">${featureName}</div>`;
            popupContent += '<div class="popup-body">';

            // Enhanced priority list: area/subdivision fields first, then standard OSM tags
            const priorityKeys = [
                'name', 'oteil', 'bezirk',  // Area/subdivision names
                'amenity', 'shop', 'tourism', 'highway', 'building', 'type',
                'operator', 'market_count', 'count',  // Counts and metrics
                'area_sq_km', 'area_ha', 'area',  // Area measurements
                'addr:street', 'addr:housenumber', 'addr:city', 'phone', 'website'
            ];

            const sortedEntries = Object.entries(properties).sort((a, b) => {
                const aIndex = priorityKeys.indexOf(a[0]);
                const bIndex = priorityKeys.indexOf(b[0]);
                if (aIndex !== -1 && bIndex !== -1) return aIndex - bIndex;
                if (aIndex !== -1) return -1;
                if (bIndex !== -1) return 1;
                return a[0].localeCompare(b[0]);
            });

            // Add attributes
            for (const [key, value] of sortedEntries) {
                if (value !== null && value !== undefined && value !== '') {
                    // Better display names for area-specific fields
                    let displayKey = key;
                    if (key === 'oteil') {
                        displayKey = 'Area/Neighborhood';
                    } else if (key === 'bezirk') {
                        displayKey = 'District';
                    } else if (key === 'market_count' || key === 'count') {
                        displayKey = key.replace(/_/g, ' ');
                    } else if (key === 'area_sq_km') {
                        displayKey = 'Area (sq km)';
                    } else if (key === 'area_ha') {
                        displayKey = 'Area (hectares)';
                    } else {
                        displayKey = key.replace(/_/g, ' ').replace(/:/g, ' ');
                    }

                    let displayValue = value;

                    if (typeof value === 'object') {
                        displayValue = JSON.stringify(value, null, 2);
                    } else if (typeof value === 'string' && value.startsWith('http')) {
                        displayValue = `<a href="${value}" target="_blank" style="color: #504E76; text-decoration: none;">üîó Link</a>`;
                    } else if (typeof value === 'number' && (key === 'area_sq_km' || key === 'area_ha')) {
                        // Format area values with 2 decimal places
                        displayValue = typeof value === 'number' ? value.toFixed(2) : value;
                    }

                    popupContent += `
                        <div class="popup-attribute">
                            <div class="popup-label">${displayKey}</div>
                            <div class="popup-value">${displayValue}</div>
                        </div>
                    `;
                }
            }

            popupContent += '</div>';
            popupContent += `<div class="popup-footer">${Object.keys(properties).length} attributes</div>`;
            popupContent += '</div>';

            return popupContent;
        }

        // Change layer color
        function changeLayerColor(layerId, newColor) {
            const layerInfo = layers.find(l => l.id === layerId);
            if (!layerInfo) return;

            // Update stored color
            layerInfo.color = newColor;

            // Remove old layer from map
            map.removeLayer(layerInfo.layer);

            // Create new layer with updated color
            const geojsonLayer = L.geoJSON(layerInfo.geojsonData, {
                style: function(feature) {
                    return {
                        color: newColor,
                        weight: 2,
                        fillOpacity: 0.3
                    };
                },
                pointToLayer: function(feature, latlng) {
                    return L.circleMarker(latlng, {
                        radius: 8,
                        fillColor: newColor,
                        color: '#fff',
                        weight: 2,
                        opacity: 1,
                        fillOpacity: 0.8
                    });
                },
                onEachFeature: function(feature, layer) {
                    if (feature.properties) {
                        layer.bindPopup(createPopupContent(feature.properties));
                    }
                }
            });

            // Add new layer to map if it was visible
            if (layerInfo.visible) {
                geojsonLayer.addTo(map);
            }

            // Update layer reference
            layerInfo.layer = geojsonLayer;

            // Update UI
            updateLayersPanel();
        }

        // Update layers panel
        function updateLayersPanel() {
            const layersList = document.getElementById('layersList');

            if (layers.length === 0) {
                layersList.innerHTML = `
                    <div class="empty-state">
                        <div class="empty-state-icon">üó∫Ô∏è</div>
                        <div class="empty-state-text">No layers yet<br>Search to add results as layers</div>
                    </div>
                `;
                return;
            }

            layersList.innerHTML = '';

            // Reverse order to show newest first
            [...layers].reverse().forEach(layerInfo => {
                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item' + (layerInfo.visible ? ' active' : '');

                const timeAgo = getTimeAgo(layerInfo.timestamp);

                layerItem.innerHTML = `
                    <div class="layer-header">
                        <div class="layer-name" title="${layerInfo.name}">${layerInfo.name}</div>
                        <div class="layer-controls">
                            <div class="layer-color-picker" title="Change color" id="colorPicker${layerInfo.id}">
                                <div class="layer-color-display" style="background-color: ${layerInfo.color}"></div>
                                <input type="color" value="${layerInfo.color}" id="colorInput${layerInfo.id}">
                            </div>
                            <div class="layer-toggle ${layerInfo.visible ? 'active' : ''}"
                                 onclick="toggleLayer(${layerInfo.id})"></div>
                                                <div class="layer-menu-wrapper">
                                                    <button class="layer-menu-btn" onclick="toggleLayerMenu(event, ${layerInfo.id})" title="More options">‚ãÆ</button>
                                                    <div class="layer-dropdown-menu" id="menu${layerInfo.id}">
                                                        <div class="layer-dropdown-item" onclick="openExportDialog(${layerInfo.id}, event)">üì• Export as GeoJSON</div>
                                                    </div>
                                                </div>
                                                                            <span class="layer-remove" onclick="removeLayer(${layerInfo.id})">√ó</span>
                        </div>
                    </div>
                    <div class="layer-info">
                        <div class="layer-count">
                            <span>üìç ${layerInfo.featureCount} features</span>
                        </div>
                        <div class="layer-time">${timeAgo}</div>
                    </div>
                `;

                layerItem.onclick = (e) => {
                    // Don't zoom if clicking controls
                    if (e.target.classList.contains('layer-toggle') ||
                        e.target.classList.contains('layer-remove') ||
                        e.target.classList.contains('layer-color-picker') ||
                        e.target.classList.contains('layer-color-display') ||
                        e.target.type === 'color') {
                        return;
                    }
                    // Display operations when layer is clicked
                    displayLayerOperations(layerInfo.id);
                    // Zoom to layer
                    zoomToLayer(layerInfo.id);
                };

                layersList.appendChild(layerItem);

                // Add event listener to color input after appending to DOM
                const colorInput = document.getElementById(`colorInput${layerInfo.id}`);
                if (colorInput) {
                    colorInput.addEventListener('click', (e) => {
                        e.stopPropagation();
                    });
                    colorInput.addEventListener('change', (e) => {
                        changeLayerColor(layerInfo.id, e.target.value);
                    });
                }
            });
        }

        // Get time ago string
        function getTimeAgo(date) {
            const seconds = Math.floor((new Date() - date) / 1000);

            if (seconds < 60) return 'Just now';
            if (seconds < 3600) return `${Math.floor(seconds / 60)}m ago`;
            if (seconds < 86400) return `${Math.floor(seconds / 3600)}h ago`;
            return `${Math.floor(seconds / 86400)}d ago`;
        }

        // Display operations for a selected layer
        function displayLayerOperations(layerId) {
            const layerInfo = layers.find(l => l.id === layerId);
            if (!layerInfo) return;

            const operationsPanel = document.getElementById('operationsPanel');
            const operationsContent = document.getElementById('operationsContent');
            const operationsTitle = document.getElementById('operationsTitle');

            // Update title
            operationsTitle.textContent = `${layerInfo.name}`;

            let content = '';

            // Display reasoning
            if (layerInfo.reasoning) {
                content += `
                    <div class="operations-section">
                        <div class="operations-section-title">Reasoning</div>
                        <div class="reasoning-box">${layerInfo.reasoning}</div>
                    </div>
                `;
            }

            // Display operations
            if (layerInfo.operations && layerInfo.operations.length > 0) {
                content += '<div class="operations-section">';
                content += '<div class="operations-section-title">Operations</div>';

                layerInfo.operations.forEach((op, index) => {
                    const operationType = op.operation.replace(/_/g, ' ').toUpperCase();
                    const description = op.description || 'No description available';
                    const params = op.parameters ? JSON.stringify(op.parameters, null, 2) : '{}';

                    content += `
                        <div class="operation-item">
                            <div style="font-weight: 600; margin-bottom: 0.5rem;">Step ${index + 1}</div>
                            <div class="operation-type">${operationType}</div>
                            <div class="operation-description">${description}</div>
                            <div class="operation-params">${params}</div>
                        </div>
                    `;
                });

                content += '</div>';
            }

            // Display datasets used
            if (layerInfo.datasetsUsed && layerInfo.datasetsUsed.length > 0) {
                content += `
                    <div class="operations-section">
                        <div class="operations-section-title">Datasets Used</div>
                        <div class="datasets-list">
                            ${layerInfo.datasetsUsed.map(dataset =>
                                `<div class="dataset-badge">${dataset}</div>`
                            ).join('')}
                        </div>
                    </div>
                `;
            }

            // Display metadata and subdivision rankings
            if (layerInfo.metadata) {
                // Check for subdivision analysis data
                if (layerInfo.metadata.subdivisions_analysis && layerInfo.metadata.rankings) {
                    content += '<div class="operations-section">';
                    content += '<div class="operations-section-title">Top Subdivisions Ranking</div>';

                    layerInfo.metadata.rankings.forEach(ranking => {
                        content += `
                            <div class="metadata-item">
                                <span class="metadata-label">#${ranking.rank}</span>
                                <span class="metadata-value">${ranking.suitable_areas_count.toLocaleString()} areas (${ranking.percentage.toFixed(2)}%)</span>
                            </div>
                        `;
                    });

                    if (layerInfo.metadata.top_subdivision) {
                        const top = layerInfo.metadata.top_subdivision;
                        content += '<div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #e0e0e0;">';
                        content += `<div style="font-weight: 600; color: #504E76; margin-bottom: 0.5rem;">Top Subdivision:</div>`;
                        content += `<div class="metadata-item"><span class="metadata-label">ID</span><span class="metadata-value">${top.osm_id}</span></div>`;
                        content += `<div class="metadata-item"><span class="metadata-label">Areas</span><span class="metadata-value">${top.suitable_areas.toLocaleString()}</span></div>`;
                        content += '</div>';
                    }

                    content += '</div>';
                } else {
                    // Regular metadata display
                    content += '<div class="operations-section">';
                    content += '<div class="operations-section-title">Metadata</div>';

                    for (const [key, value] of Object.entries(layerInfo.metadata)) {
                        // Skip subdivision-related keys
                        if (key.includes('subdivision') || key === 'rankings' || key === 'top_subdivision') continue;

                        const displayKey = key.replace(/_/g, ' ').charAt(0).toUpperCase() +
                                         key.replace(/_/g, ' ').slice(1);
                        const displayValue = typeof value === 'object' ? JSON.stringify(value) : value;
                        content += `
                            <div class="metadata-item">
                                <span class="metadata-label">${displayKey}</span>
                                <span class="metadata-value">${displayValue}</span>
                            </div>
                        `;
                    }

                    content += '</div>';
                }
            }

            // Display execution time
            if (layerInfo.executionTime) {
                content += `
                    <div class="operations-section">
                        <div class="metadata-item">
                            <span class="metadata-label">Execution Time</span>
                            <span class="metadata-value">${layerInfo.executionTime.toFixed(2)}s</span>
                        </div>
                    </div>
                `;
            }

            // Show empty state if no operations data
            if (!content) {
                content = '<div class="no-selection">No operations data available</div>';
            }

            operationsContent.innerHTML = content;
            operationsPanel.classList.remove('operations-panel-hidden');
        }

        // Hide operations panel
        function hideOperationsPanel() {
            const operationsPanel = document.getElementById('operationsPanel');
            operationsPanel.classList.add('operations-panel-hidden');
        }

        // Toggle layer visibility
        function toggleLayer(layerId) {
            const layerInfo = layers.find(l => l.id === layerId);
            if (!layerInfo) return;

            layerInfo.visible = !layerInfo.visible;

            if (layerInfo.visible) {
                map.addLayer(layerInfo.layer);
            } else {
                map.removeLayer(layerInfo.layer);
            }

            updateLayersPanel();
        }

        // Remove layer
        function removeLayer(layerId) {
            const layerInfo = layers.find(l => l.id === layerId);
            if (!layerInfo) return;

            map.removeLayer(layerInfo.layer);
            layers = layers.filter(l => l.id !== layerId);
            updateLayersPanel();

            showNotification(`Layer "${layerInfo.name}" removed`, 'success');
        }
        // Current layer ID for export
        let currentExportLayerId = null;

        // Toggle layer dropdown menu
        function toggleLayerMenu(event, layerId) {
            event.stopPropagation();
            
            // Close all other menus first
            document.querySelectorAll('.layer-dropdown-menu').forEach(menu => {
                if (menu.id !== `menu${layerId}`) {
                    menu.classList.remove('active');
                }
            });

            // Toggle current menu
            const menu = document.getElementById(`menu${layerId}`);
            if (menu) {
                menu.classList.toggle('active');
            }
        }

        // Close all menus when clicking outside
        document.addEventListener('click', function() {
            document.querySelectorAll('.layer-dropdown-menu').forEach(menu => {
                menu.classList.remove('active');
            });
        });

        // Open export dialog
        function openExportDialog(layerId, event) {
            event.stopPropagation();
            currentExportLayerId = layerId;
            const overlay = document.getElementById('exportDialogOverlay');
            if (overlay) {
                overlay.classList.add('active');
            }
            // Close the menu
            const menu = document.getElementById(`menu${layerId}`);
            if (menu) {
                menu.classList.remove('active');
            }
        }

        // Close export dialog
        function closeExportDialog() {
            const overlay = document.getElementById('exportDialogOverlay');
            if (overlay) {
                overlay.classList.remove('active');
            }
            currentExportLayerId = null;
        }

        // Perform export
        function performExport() {
            if (!currentExportLayerId) {
                showNotification('No layer selected for export', 'error');
                return;
            }

            const layerInfo = layers.find(l => l.id === currentExportLayerId);
            if (!layerInfo) {
                showNotification('Layer not found', 'error');
                return;
            }

            // Get export options
            const includeProperties = document.getElementById('exportIncludeProperties').checked;
            const formatSelect = document.getElementById('exportFormatSelect');
            const format = formatSelect ? formatSelect.value : 'minified';
            const includeCRS = document.getElementById('exportIncludeCRS').checked;
            const includeBbox = document.getElementById('exportIncludeBbox').checked;

            // Get the GeoJSON data from the layer
            let geojsonData = layerInfo.geojsonData;
            
            if (!geojsonData) {
                showNotification('No GeoJSON data available for this layer', 'error');
                return;
            }

            // Create a copy to modify
            let exportData = JSON.parse(JSON.stringify(geojsonData));

            // Remove properties if not needed
            if (!includeProperties) {
                if (exportData.features) {
                    exportData.features.forEach(feature => {
                        feature.properties = {};
                    });
                }
            }

            // Add CRS if requested
            if (includeCRS) {
                exportData.crs = {
                    type: "name",
                    properties: {
                        name: "EPSG:4326"
                    }
                };
            }

            // Add bounding box if requested
            if (includeBbox) {
                const bounds = layerInfo.layer.getBounds();
                if (bounds && bounds.isValid()) {
                    exportData.bbox = [
                        bounds.getWest(),
                        bounds.getSouth(),
                        bounds.getEast(),
                        bounds.getNorth()
                    ];
                }
            }

            // Convert to JSON string
            let jsonString;
            if (format === 'pretty') {
                jsonString = JSON.stringify(exportData, null, 2);
            } else {
                jsonString = JSON.stringify(exportData);
            }

            // Create blob and download
            const blob = new Blob([jsonString], { type: 'application/geo+json' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `${layerInfo.name.replace(/\s+/g, '_')}_${new Date().toISOString().split('T')[0]}.geojson`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            // Show success notification
            showNotification(`Layer "${layerInfo.name}" exported successfully`, 'success');
            
            // Close dialog
            closeExportDialog();
        }


        // Zoom to layer
        function zoomToLayer(layerId) {
            const layerInfo = layers.find(l => l.id === layerId);
            if (!layerInfo) return;

            if (layerInfo.layer.getBounds().isValid()) {
                map.fitBounds(layerInfo.layer.getBounds(), { padding: [50, 50] });
            }
        }

        // Toggle user location
        function toggleLocation() {
            if (userLocation) {
                // Disable location
                disableLocation();
            } else {
                // Enable location
                enableLocation();
            }
        }

        // Enable user location
        function enableLocation() {
            if (!navigator.geolocation) {
                showNotification('Geolocation is not supported by your browser', 'error');
                return;
            }

            const locationBtn = document.getElementById('locationBtn');
            const locationText = document.getElementById('locationText');
            const locationIcon = document.getElementById('locationIcon');

            locationBtn.disabled = true;
            locationText.textContent = 'Locating...';
            locationIcon.textContent = 'üîÑ';

            navigator.geolocation.getCurrentPosition(
                (position) => {
                    // Success - save user location
                    userLocation = {
                        lat: position.coords.latitude,
                        lon: position.coords.longitude
                    };

                    console.log('‚úÖ Location enabled:', userLocation);

                    // Update button UI
                    locationBtn.disabled = false;
                    locationBtn.classList.add('active');
                    locationText.textContent = 'Location On';
                    locationIcon.textContent = 'üìç';

                    // Add marker to map
                    if (userLocationMarker) {
                        map.removeLayer(userLocationMarker);
                    }
                    if (userLocationCircle) {
                        map.removeLayer(userLocationCircle);
                    }

                    // Add circle marker for user location
                    userLocationMarker = L.circleMarker([userLocation.lat, userLocation.lon], {
                        radius: 8,
                        fillColor: '#504E76',
                        color: '#fff',
                        weight: 3,
                        opacity: 1,
                        fillOpacity: 1
                    }).addTo(map);

                    // Add accuracy circle
                    const accuracy = position.coords.accuracy || 100;
                    userLocationCircle = L.circle([userLocation.lat, userLocation.lon], {
                        radius: accuracy,
                        fillColor: '#504E76',
                        color: '#504E76',
                        weight: 1,
                        opacity: 0.3,
                        fillOpacity: 0.1
                    }).addTo(map);

                    // Add popup to marker
                    userLocationMarker.bindPopup(`
                        <div class="popup-card">
                            <div class="popup-header">Your Location</div>
                            <div class="popup-body">
                                <div class="popup-attribute">
                                    <div class="popup-label">Latitude</div>
                                    <div class="popup-value">${userLocation.lat.toFixed(6)}</div>
                                </div>
                                <div class="popup-attribute">
                                    <div class="popup-label">Longitude</div>
                                    <div class="popup-value">${userLocation.lon.toFixed(6)}</div>
                                </div>
                                <div class="popup-attribute">
                                    <div class="popup-label">Accuracy</div>
                                    <div class="popup-value">¬±${accuracy.toFixed(0)}m</div>
                                </div>
                            </div>
                        </div>
                    `);

                    // Pan map to user location
                    map.setView([userLocation.lat, userLocation.lon], 14);

                    showNotification('Location enabled! Try "Find toilets near me"', 'success');
                },
                (error) => {
                    // Error handling
                    locationBtn.disabled = false;
                    locationText.textContent = 'My Location';
                    locationIcon.textContent = 'üìç';

                    let errorMessage = 'Unable to get your location';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage = 'Location permission denied';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage = 'Location information unavailable';
                            break;
                        case error.TIMEOUT:
                            errorMessage = 'Location request timed out';
                            break;
                    }
                    showNotification(errorMessage, 'error');
                },
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }

        // Disable user location
        function disableLocation() {
            userLocation = null;

            // Update button UI
            const locationBtn = document.getElementById('locationBtn');
            const locationText = document.getElementById('locationText');
            const locationIcon = document.getElementById('locationIcon');

            locationBtn.classList.remove('active');
            locationText.textContent = 'My Location';
            locationIcon.textContent = 'üìç';

            // Remove markers from map
            if (userLocationMarker) {
                map.removeLayer(userLocationMarker);
                userLocationMarker = null;
            }
            if (userLocationCircle) {
                map.removeLayer(userLocationCircle);
                userLocationCircle = null;
            }

            showNotification('Location disabled', 'success');
        }

        // Detect if query is DEM-related
        function isDEMQuery(question) {
            const demKeywords = [
                'elevation', 'terrain', 'slope', 'steep', 'flat', 'dem',
                'develop', 'suitable', 'building', 'construction', 'build',
                'flood', 'water', 'relief', 'hillshade', 'aspect',
                'altitude', 'height', 'rise', 'descent', 'topography',
                'steepness', 'gradient', 'relief', 'contour',
                'erosion', 'watershed', 'stream', 'drainage'
            ];

            const lowerQuestion = question.toLowerCase();
            return demKeywords.some(keyword => lowerQuestion.includes(keyword));
        }

        // Process DEM results and create a layer
        function processDEMResult(data, query) {
            // Generate a meaningful layer name based on query
            let layerName = 'Terrain Analysis';
            if (query.includes('develop') || query.includes('suitable')) {
                layerName = 'Development Suitability';
            } else if (query.includes('slope') || query.includes('steep')) {
                layerName = 'Slope Analysis';
            } else if (query.includes('classify') || query.includes('classification')) {
                layerName = 'Terrain Classification';
            } else if (query.includes('flood')) {
                layerName = 'Flood Risk Assessment';
            }

            let geojson;

            // Check if data already contains actual GeoJSON features (from spatial DEM analysis)
            if (data.type === 'FeatureCollection' && data.features && data.features.length > 0) {
                // Use actual spatial data returned from API
                console.log(`‚úÖ Using actual spatial GeoJSON with ${data.features.length} features`);
                geojson = data;
            } else {
                // Fall back to dummy point with metadata for text-based results
                const demFeature = {
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [13.405, 52.52] // Berlin center
                    },
                    properties: {
                        type: 'DEM Analysis',
                        query: query,
                        analysis_type: layerName,
                        ...(data.metadata || {})
                    }
                };

                geojson = {
                    type: 'FeatureCollection',
                    features: [demFeature]
                };
            }

            return {
                layerName: layerName,
                geojson: geojson,
                summary: data.summary || 'Terrain analysis complete'
            };
        }

        // Execute search
        async function executeSearch() {
            const query = document.getElementById('searchInput').value.trim();

            if (!query) {
                showNotification('Please enter a search query', 'error');
                return;
            }

            const searchBtn = document.getElementById('searchBtn');
            searchBtn.disabled = true;

            setLoading(true, 'Processing...');

            try {
                // Determine query type
                const isDEM = isDEMQuery(query);
                const endpoint = isDEM ? '/api/dem/query' : '/api/query';

                console.log(`üìç Query Type: ${isDEM ? 'DEM' : 'Spatial'}`);

                let response;

                if (isDEM) {
                    // DEM query
                    const demUrl = new URL(`${API_URL}/dem/query`, window.location.origin);
                    demUrl.searchParams.append('question', query);

                    response = await fetch(demUrl.toString(), {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });
                } else {
                    // Spatial query
                    const payload = { question: query };

                    // Add user location if available
                    if (userLocation) {
                        payload.user_location = userLocation;
                        console.log('üåç Using user location:', userLocation);
                    }

                    response = await fetch(`${API_URL}/query`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify(payload)
                    });
                }

                const data = await response.json();

                // Debug: Log the full response
                console.log('üìä API Response:', data);

                if (isDEM) {
                    // Handle DEM response
                    if (data.success) {
                        // Pass the actual data field from API response (which contains GeoJSON)
                        const processed = processDEMResult(data.data, query);

                        // For subdivision analysis, include ranking info in metadata
                        let metadata = data.metadata || {};
                        if (data.ranking && data.top_subdivision) {
                            metadata.subdivisions_analysis = true;
                            metadata.rankings = data.ranking;
                            metadata.top_subdivision = data.top_subdivision;
                        }

                        addLayer(
                            processed.layerName,
                            processed.geojson,
                            query,
                            data.operations || [],
                            data.reasoning || processed.summary,
                            data.datasets_used || [],
                            metadata,
                            data.execution_time || 0
                        );

                        const featureCount = processed.geojson.features ? processed.geojson.features.length : 1;
                        showNotification(`‚úÖ ${processed.layerName}: ${featureCount} features loaded (Top subdivision)`, 'success');
                    } else {
                        showNotification(data.error || 'DEM analysis failed', 'error');
                    }
                } else {
                    // Handle Spatial response
                    console.log('üîß Operations:', data.operations);
                    console.log('üí≠ Reasoning:', data.reasoning);
                    console.log('üìö Datasets:', data.datasets_used);

                    if (data.success && data.data && data.data.features) {
                        // Use DeepSeek-generated layer name if available, fallback to client-side generation
                        const layerName = data.layer_name || generateLayerName(query, data.data);

                        // Pass all operation data to addLayer
                        addLayer(
                            layerName,
                            data.data,
                            query,
                            data.operations,      // Operations performed
                            data.reasoning,       // AI reasoning
                            data.datasets_used,   // Datasets used
                            data.metadata,        // Metadata
                            data.execution_time   // Execution time
                        );

                        showNotification(`Found ${data.data.features.length} results`, 'success');
                    } else {
                        showNotification(data.error || 'No results found', 'error');
                    }
                }

                // Clear search input
                document.getElementById('searchInput').value = '';

            } catch (error) {
                showNotification(`Error: ${error.message}`, 'error');
                console.error('‚ùå Search error:', error);
            } finally {
                setLoading(false);
                searchBtn.disabled = false;
            }
        }

        // Allow Enter key to search
        document.getElementById('searchInput').addEventListener('keydown', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                executeSearch();
            }
        });

        // Locate user function
        function locateUser() {
            const locateBtn = document.getElementById('locateBtn');

            // Check if geolocation is supported
            if (!navigator.geolocation) {
                showNotification('Geolocation is not supported by your browser', 'error');
                return;
            }

            // Add loading animation
            locateBtn.classList.add('locating');

            navigator.geolocation.getCurrentPosition(
                // Success callback
                function(position) {
                    const lat = position.coords.latitude;
                    const lng = position.coords.longitude;
                    const accuracy = position.coords.accuracy;

                    // Remove existing location marker if any
                    if (userLocationMarker) {
                        map.removeLayer(userLocationMarker);
                    }
                    if (userLocationCircle) {
                        map.removeLayer(userLocationCircle);
                    }

                    // Create custom icon for user location
                    const userIcon = L.divIcon({
                        className: 'user-location-marker',
                        html: `
                            <div style="
                                width: 20px;
                                height: 20px;
                                background: #504E76;
                                border: 3px solid white;
                                border-radius: 50%;
                                box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
                            "></div>
                        `,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });

                    // Add marker at user location
                    userLocationMarker = L.marker([lat, lng], {
                        icon: userIcon
                    }).addTo(map);

                    // Add accuracy circle
                    userLocationCircle = L.circle([lat, lng], {
                        radius: accuracy,
                        color: '#504E76',
                        fillColor: '#504E76',
                        fillOpacity: 0.15,
                        weight: 1
                    }).addTo(map);

                    // Bind popup with location info
                    userLocationMarker.bindPopup(`
                        <div style="text-align: center;">
                            <strong>üìç Your Location</strong><br>
                            <small>
                                Latitude: ${lat.toFixed(6)}<br>
                                Longitude: ${lng.toFixed(6)}<br>
                                Accuracy: ¬±${Math.round(accuracy)}m
                            </small>
                        </div>
                    `).openPopup();

                    // Center map on user location with appropriate zoom
                    map.setView([lat, lng], 15);

                    // Remove loading animation
                    locateBtn.classList.remove('locating');

                    showNotification('Location found!', 'success');
                },
                // Error callback
                function(error) {
                    locateBtn.classList.remove('locating');

                    let errorMessage = 'Unable to retrieve your location';
                    switch(error.code) {
                        case error.PERMISSION_DENIED:
                            errorMessage = 'Location access denied. Please enable location permissions.';
                            break;
                        case error.POSITION_UNAVAILABLE:
                            errorMessage = 'Location information is unavailable.';
                            break;
                        case error.TIMEOUT:
                            errorMessage = 'Location request timed out.';
                            break;
                    }
                    showNotification(errorMessage, 'error');
                },
                // Options
                {
                    enableHighAccuracy: true,
                    timeout: 10000,
                    maximumAge: 0
                }
            );
        }

        // Auto-locate on page load (optional - commented out by default)
        // Uncomment the next line to automatically locate user when page loads
        // window.addEventListener('load', () => setTimeout(locateUser, 1000));
    </script>
</body>
</html>
