"""
SQL Query Generator for PostGIS spatial operations
Translates DeepSeek operation plans into executable PostGIS SQL
"""

from typing import Dict, Any, List
from app.models.query_model import GeospatialOperation, OperationPlan
import geopandas as gpd
from app.utils.database import db_manager
from app.utils.sql_validator import validate_and_fix_sql


class SQLQueryGenerator:
    """Generate and execute PostGIS SQL queries from operation plans"""

    def __init__(self):
        self.schema = "vector"

    def execute_plan(self, plan: OperationPlan) -> gpd.GeoDataFrame:
        """
        Execute an operation plan by translating to SQL and running in PostGIS.

        Args:
            plan: OperationPlan with operations

        Returns:
            GeoDataFrame with results
        """
        result_gdf = None

        for operation in plan.operations:
            if operation.operation == "load":
                result_gdf = self._execute_load(operation)
            elif operation.operation == "spatial_query":
                result_gdf = self._execute_spatial_query(operation)
            elif operation.operation == "raster_analysis":
                result_gdf = self._execute_raster_analysis(operation)
            elif operation.operation == "buffer":
                result_gdf = self._execute_buffer(operation, result_gdf)
            elif operation.operation == "intersection":
                result_gdf = self._execute_intersection(operation, result_gdf)
            elif operation.operation == "filter":
                result_gdf = self._execute_filter(operation, result_gdf)
            elif operation.operation == "aggregate":
                # Aggregation handled differently
                result_gdf = self._execute_aggregate(operation, result_gdf)
            elif operation.operation == "sort":
                result_gdf = self._execute_sort(operation, result_gdf)

        return result_gdf

    def _execute_load(self, operation: GeospatialOperation) -> gpd.GeoDataFrame:
        """
        Execute a load operation.
        Can use either pre-written SQL or generate from dataset name.
        """
        params = operation.parameters

        # Check if SQL is provided directly
        if "sql" in params:
            sql = params["sql"]
            return db_manager.execute_spatial_query(sql)

        # Otherwise, generate simple SELECT
        dataset = params.get("dataset", "")
        table_name = dataset.replace("vector.", "")  # Clean schema if present

        # Check for region filter in context
        where_clause = ""
        if "region" in params:
            region = params["region"]
            where_clause = f" WHERE region = '{region}'"

        sql = f"SELECT * FROM {self.schema}.{table_name}{where_clause}"

        return db_manager.execute_spatial_query(sql)

    def _execute_spatial_query(self, operation: GeospatialOperation) -> gpd.GeoDataFrame:
        """
        Execute a direct spatial SQL query.
        This is for complex queries generated by DeepSeek.
        Includes automatic SQL validation and error correction.
        """
        sql = operation.parameters.get("sql", "")

        if not sql:
            raise ValueError("No SQL provided for spatial_query operation")

        # Validate and fix SQL syntax errors
        is_valid, fixed_sql, errors_found = validate_and_fix_sql(sql)

        if errors_found:
            print(f"⚠️  SQL syntax issues detected and auto-corrected:")
            for error in errors_found:
                print(f"   - {error}")
            print(f"\n Original SQL:\n{sql}\n")
            print(f"Fixed SQL:\n{fixed_sql}\n")
            sql = fixed_sql

        # CRITICAL: Ensure geometry is in the SELECT clause
        sql = self._ensure_geometry_in_select(sql)

        return db_manager.execute_spatial_query(sql)

    def _ensure_geometry_in_select(self, sql: str) -> str:
        """
        Ensure geometry column is included in SELECT clause for spatial queries.
        If missing, add it to prevent "missing geometry column" errors.

        Examples:
            "SELECT bezirk FROM table" → "SELECT bezirk, geometry FROM table"
            "SELECT * FROM table" → "SELECT * FROM table" (no change, * includes geometry)
        """
        import re

        # If query uses SELECT *, it's fine (includes all columns)
        if re.search(r'SELECT\s+\*', sql, re.IGNORECASE):
            return sql

        # Check if geometry is already in the SELECT clause
        if re.search(r'SELECT\s+.*\bgeometry\b', sql, re.IGNORECASE | re.DOTALL):
            return sql

        # If neither SELECT * nor explicit geometry, add geometry to SELECT
        # Find the SELECT clause and add geometry
        select_pattern = r'(SELECT\s+)([^F]+?)(FROM)'

        def add_geometry(match):
            select_keyword = match.group(1)
            select_columns = match.group(2).rstrip(', ')
            from_keyword = match.group(3)

            # Add geometry unless it ends with DISTINCT * or similar
            if not select_columns.strip().endswith('*'):
                select_columns = f"{select_columns}, geometry"

            return f"{select_keyword}{select_columns} {from_keyword}"

        fixed_sql = re.sub(select_pattern, add_geometry, sql, flags=re.IGNORECASE | re.DOTALL)

        if fixed_sql != sql:
            print(f"⚠️  Geometry column was missing from SELECT - auto-added")
            print(f"   Original: {sql[:80]}...")
            print(f"   Fixed:    {fixed_sql[:80]}...")

        return fixed_sql

    def _execute_buffer(self, operation: GeospatialOperation, gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Execute buffer operation using PostGIS.
        If GeoDataFrame is provided, save it first, then buffer.
        """
        distance = operation.parameters.get("distance", 1000)

        # If we have a GeoDataFrame, we need to either:
        # 1. Save it to temp table and buffer in PostGIS
        # 2. Buffer in GeoPandas

        # For simplicity, buffer in GeoPandas
        if gdf is None:
            raise ValueError("No data to buffer")

        # Ensure projected CRS
        if gdf.crs and gdf.crs.is_geographic:
            gdf = gdf.to_crs("EPSG:3857")

        gdf['geometry'] = gdf.geometry.buffer(distance)
        return gdf

    def _execute_intersection(self, operation: GeospatialOperation, gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Execute spatial intersection.
        """
        other_dataset = operation.parameters.get("with", operation.parameters.get("dataset"))

        if not other_dataset:
            raise ValueError("No dataset specified for intersection")

        # Load the other dataset
        other_gdf = db_manager.load_vector_from_db(other_dataset, schema=self.schema)

        # Perform intersection
        if gdf.crs != other_gdf.crs:
            other_gdf = other_gdf.to_crs(gdf.crs)

        result = gpd.overlay(gdf, other_gdf, how='intersection')
        return result

    def _execute_filter(self, operation: GeospatialOperation, gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Filter features by attribute.
        """
        if gdf is None:
            raise ValueError("No data to filter")

        column = operation.parameters.get("column")
        value = operation.parameters.get("value")
        operator = operation.parameters.get("operator", "==")

        if column and value:
            if operator == "==":
                gdf = gdf[gdf[column] == value]
            elif operator == ">":
                gdf = gdf[gdf[column] > value]
            elif operator == "<":
                gdf = gdf[gdf[column] < value]
            elif operator == "contains":
                gdf = gdf[gdf[column].str.contains(value, case=False, na=False)]

        return gdf

    def _execute_aggregate(self, operation: GeospatialOperation, gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Execute aggregation operation.
        """
        if gdf is None:
            raise ValueError("No data to aggregate")

        agg_type = operation.parameters.get("type", "count")
        column = operation.parameters.get("column")

        # Add aggregation results as metadata
        if not hasattr(gdf, 'metadata'):
            gdf.metadata = {}

        if agg_type == "count":
            gdf.metadata['count'] = len(gdf)
        elif agg_type == "sum" and column:
            gdf.metadata['sum'] = gdf[column].sum()
        elif agg_type == "mean" and column:
            gdf.metadata['mean'] = gdf[column].mean()
        elif agg_type == "area":
            # Calculate total area
            if gdf.crs and gdf.crs.is_geographic:
                temp_gdf = gdf.to_crs("EPSG:3857")
                gdf.metadata['total_area_km2'] = temp_gdf.geometry.area.sum() / 1_000_000
            else:
                gdf.metadata['total_area'] = gdf.geometry.area.sum()

        return gdf

    def _execute_sort(self, operation: GeospatialOperation, gdf: gpd.GeoDataFrame) -> gpd.GeoDataFrame:
        """
        Sort features by attribute.
        """
        if gdf is None:
            raise ValueError("No data to sort")

        column = operation.parameters.get("by", operation.parameters.get("column"))
        ascending = operation.parameters.get("order", "ascending") == "ascending"

        if column and column in gdf.columns:
            gdf = gdf.sort_values(by=column, ascending=ascending)

        # Apply limit if specified
        limit = operation.parameters.get("limit")
        if limit:
            gdf = gdf.head(limit)

        return gdf

    def build_distance_query(
        self,
        table1: str,
        table2: str,
        distance: float,
        region: str = None
    ) -> str:
        """
        Build a SQL query for distance-based spatial operations.

        Args:
            table1: First table name
            table2: Second table name
            distance: Distance in meters
            region: Optional region filter

        Returns:
            SQL query string
        """
        where_clause = ""
        if region:
            where_clause = f" WHERE a.region = '{region}'"

        sql = f"""
        SELECT DISTINCT a.*
        FROM {self.schema}.{table1} a, {self.schema}.{table2} b
        {where_clause}
        AND ST_DWithin(a.geometry::geography, b.geometry::geography, {distance})
        """

        return sql.strip()

    def build_intersection_query(
        self,
        table1: str,
        table2: str,
        region: str = None
    ) -> str:
        """
        Build a SQL query for intersection operations.

        Args:
            table1: First table name
            table2: Second table name
            region: Optional region filter

        Returns:
            SQL query string
        """
        where_clause = ""
        if region:
            where_clause = f" AND a.region = '{region}'"

        sql = f"""
        SELECT a.*
        FROM {self.schema}.{table1} a, {self.schema}.{table2} b
        WHERE ST_Intersects(a.geometry, b.geometry){where_clause}
        """

        return sql.strip()

    def build_count_query(self, table: str, region: str = None) -> str:
        """
        Build a SQL query to count features.

        Args:
            table: Table name
            region: Optional region filter

        Returns:
            SQL query string
        """
        where_clause = ""
        if region:
            where_clause = f" WHERE region = '{region}'"

        sql = f"""
        SELECT COUNT(*) as count
        FROM {self.schema}.{table}{where_clause}
        """

        return sql.strip()

    def _execute_raster_analysis(self, operation: GeospatialOperation) -> gpd.GeoDataFrame:
        """
        Execute raster analysis operation.
        Routes to SpatialEngine's raster operations.

        Returns GeoDataFrame with vectorized results.
        """
        from app.utils.spatial_engine import SpatialEngine

        engine = SpatialEngine()

        # Convert GeospatialOperation to dict format expected by raster module
        raster_op = {
            'type': operation.parameters.get('type'),
            'params': operation.parameters
        }

        result = engine.execute_raster_operation(raster_op)

        if not result.get('success'):
            raise ValueError(result.get('error', 'Raster operation failed'))

        # If result has GeoJSON data, convert to GeoDataFrame
        if 'data' in result and result['data'].get('type') == 'FeatureCollection':
            import json
            gdf = gpd.GeoDataFrame.from_features(result['data']['features'])
            gdf.crs = "EPSG:4326"

            # Attach metadata
            if 'metadata' in result:
                gdf.metadata = result['metadata']

            return gdf

        # If no GeoJSON (just stats), return empty GeoDataFrame with metadata
        gdf = gpd.GeoDataFrame()
        gdf.metadata = result.get('metadata', {})
        return gdf


# Global instance
sql_generator = SQLQueryGenerator()
